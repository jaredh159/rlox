#[derive(Debug, PartialEq, Clone)]
pub enum Token {
  LeftParen(usize),
  RightParen(usize),
  LeftBrace(usize),
  RightBrace(usize),
  Comma(usize),
  Dot(usize),
  Minus(usize),
  Plus(usize),
  Semicolon(usize),
  Slash(usize),
  Star(usize),
  Bang(usize),
  BangEqual(usize),
  Equal(usize),
  EqualEqual(usize),
  Greater(usize),
  GreaterEqual(usize),
  Less(usize),
  LessEqual(usize),
  Identifier(usize, String),
  String(usize, String),
  Number(usize, f64),
  And(usize),
  Class(usize),
  Else(usize),
  False(usize),
  Fun(usize),
  For(usize),
  If(usize),
  Nil(usize),
  Or(usize),
  Print(usize),
  Return(usize),
  Super(usize),
  This(usize),
  True(usize),
  Var(usize),
  While(usize),
  Eof(usize),
  Illegal(usize, String),
}

impl Token {
  pub fn line(&self) -> usize {
    match self {
      Token::LeftParen(line) => *line,
      Token::RightParen(line) => *line,
      Token::LeftBrace(line) => *line,
      Token::RightBrace(line) => *line,
      Token::Comma(line) => *line,
      Token::Dot(line) => *line,
      Token::Minus(line) => *line,
      Token::Plus(line) => *line,
      Token::Semicolon(line) => *line,
      Token::Slash(line) => *line,
      Token::Star(line) => *line,
      Token::Bang(line) => *line,
      Token::BangEqual(line) => *line,
      Token::Equal(line) => *line,
      Token::EqualEqual(line) => *line,
      Token::Greater(line) => *line,
      Token::GreaterEqual(line) => *line,
      Token::Less(line) => *line,
      Token::LessEqual(line) => *line,
      Token::Identifier(line, _) => *line,
      Token::String(line, _) => *line,
      Token::Number(line, _) => *line,
      Token::And(line) => *line,
      Token::Class(line) => *line,
      Token::Else(line) => *line,
      Token::False(line) => *line,
      Token::Fun(line) => *line,
      Token::For(line) => *line,
      Token::If(line) => *line,
      Token::Nil(line) => *line,
      Token::Or(line) => *line,
      Token::Print(line) => *line,
      Token::Return(line) => *line,
      Token::Super(line) => *line,
      Token::This(line) => *line,
      Token::True(line) => *line,
      Token::Var(line) => *line,
      Token::While(line) => *line,
      Token::Eof(line) => *line,
      Token::Illegal(line, _) => *line,
    }
  }

  pub fn lexeme(&self) -> &str {
    match self {
      Token::LeftParen(_) => "(",
      Token::RightParen(_) => ")",
      Token::LeftBrace(_) => "[",
      Token::RightBrace(_) => "]",
      Token::Comma(_) => ",",
      Token::Dot(_) => ".",
      Token::Minus(_) => "-",
      Token::Plus(_) => "+",
      Token::Semicolon(_) => ";",
      Token::Slash(_) => "/",
      Token::Star(_) => "*",
      Token::Bang(_) => "!",
      Token::BangEqual(_) => "!=",
      Token::Equal(_) => "=",
      Token::EqualEqual(_) => "==",
      Token::Greater(_) => ">",
      Token::GreaterEqual(_) => ">=",
      Token::Less(_) => "<",
      Token::LessEqual(_) => "<=",
      Token::Identifier(_, ident) => ident,
      Token::String(_, string) => string,
      Token::Number(_, _) => todo!("switch Token::Number to hold str, make eq, hash"),
      Token::And(_) => "and",
      Token::Class(_) => "class",
      Token::Else(_) => "else",
      Token::False(_) => "false",
      Token::Fun(_) => "fun",
      Token::For(_) => "for",
      Token::If(_) => "if",
      Token::Nil(_) => "nil",
      Token::Or(_) => "or",
      Token::Print(_) => "print",
      Token::Return(_) => "return",
      Token::Super(_) => "super",
      Token::This(_) => "this",
      Token::True(_) => "true",
      Token::Var(_) => "var",
      Token::While(_) => "while",
      Token::Eof(_) => "",
      Token::Illegal(_, illegal) => illegal,
    }
  }

  pub fn get_type(&self) -> TokenType {
    match self {
      Token::LeftParen(_) => TokenType::LeftParen,
      Token::RightParen(_) => TokenType::RightParen,
      Token::LeftBrace(_) => TokenType::LeftBrace,
      Token::RightBrace(_) => TokenType::RightBrace,
      Token::Comma(_) => TokenType::Comma,
      Token::Dot(_) => TokenType::Dot,
      Token::Minus(_) => TokenType::Minus,
      Token::Plus(_) => TokenType::Plus,
      Token::Semicolon(_) => TokenType::Semicolon,
      Token::Slash(_) => TokenType::Slash,
      Token::Star(_) => TokenType::Star,
      Token::Bang(_) => TokenType::Bang,
      Token::BangEqual(_) => TokenType::BangEqual,
      Token::Equal(_) => TokenType::Equal,
      Token::EqualEqual(_) => TokenType::EqualEqual,
      Token::Greater(_) => TokenType::Greater,
      Token::GreaterEqual(_) => TokenType::GreaterEqual,
      Token::Less(_) => TokenType::Less,
      Token::LessEqual(_) => TokenType::LessEqual,
      Token::Identifier(_, _) => TokenType::Identifier,
      Token::String(_, _) => TokenType::Str,
      Token::Number(_, _) => TokenType::Number,
      Token::And(_) => TokenType::And,
      Token::Class(_) => TokenType::Class,
      Token::Else(_) => TokenType::Else,
      Token::False(_) => TokenType::False,
      Token::Fun(_) => TokenType::Fun,
      Token::For(_) => TokenType::For,
      Token::If(_) => TokenType::If,
      Token::Nil(_) => TokenType::Nil,
      Token::Or(_) => TokenType::Or,
      Token::Print(_) => TokenType::Print,
      Token::Return(_) => TokenType::Return,
      Token::Super(_) => TokenType::Super,
      Token::This(_) => TokenType::This,
      Token::True(_) => TokenType::True,
      Token::Var(_) => TokenType::Var,
      Token::While(_) => TokenType::While,
      Token::Eof(_) => TokenType::Eof,
      Token::Illegal(_, _) => TokenType::Illegal,
    }
  }

  pub fn is_type(&self, token_type: TokenType) -> bool {
    match self {
      Token::LeftParen(_) => token_type == TokenType::LeftParen,
      Token::RightParen(_) => token_type == TokenType::RightParen,
      Token::LeftBrace(_) => token_type == TokenType::LeftBrace,
      Token::RightBrace(_) => token_type == TokenType::RightBrace,
      Token::Comma(_) => token_type == TokenType::Comma,
      Token::Dot(_) => token_type == TokenType::Dot,
      Token::Minus(_) => token_type == TokenType::Minus,
      Token::Plus(_) => token_type == TokenType::Plus,
      Token::Semicolon(_) => token_type == TokenType::Semicolon,
      Token::Slash(_) => token_type == TokenType::Slash,
      Token::Star(_) => token_type == TokenType::Star,
      Token::Bang(_) => token_type == TokenType::Bang,
      Token::BangEqual(_) => token_type == TokenType::BangEqual,
      Token::Equal(_) => token_type == TokenType::Equal,
      Token::EqualEqual(_) => token_type == TokenType::EqualEqual,
      Token::Greater(_) => token_type == TokenType::Greater,
      Token::GreaterEqual(_) => token_type == TokenType::GreaterEqual,
      Token::Less(_) => token_type == TokenType::Less,
      Token::LessEqual(_) => token_type == TokenType::LessEqual,
      Token::Identifier(_, _) => token_type == TokenType::Identifier,
      Token::String(_, _) => token_type == TokenType::Str,
      Token::Number(_, _) => token_type == TokenType::Number,
      Token::And(_) => token_type == TokenType::And,
      Token::Class(_) => token_type == TokenType::Class,
      Token::Else(_) => token_type == TokenType::Else,
      Token::False(_) => token_type == TokenType::False,
      Token::Fun(_) => token_type == TokenType::Fun,
      Token::For(_) => token_type == TokenType::For,
      Token::If(_) => token_type == TokenType::If,
      Token::Nil(_) => token_type == TokenType::Nil,
      Token::Or(_) => token_type == TokenType::Or,
      Token::Print(_) => token_type == TokenType::Print,
      Token::Return(_) => token_type == TokenType::Return,
      Token::Super(_) => token_type == TokenType::Super,
      Token::This(_) => token_type == TokenType::This,
      Token::True(_) => token_type == TokenType::True,
      Token::Var(_) => token_type == TokenType::Var,
      Token::While(_) => token_type == TokenType::While,
      Token::Eof(_) => token_type == TokenType::Eof,
      Token::Illegal(_, _) => token_type == TokenType::Illegal,
    }
  }
}

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum TokenType {
  LeftParen,
  RightParen,
  LeftBrace,
  RightBrace,
  Comma,
  Dot,
  Minus,
  Plus,
  Semicolon,
  Slash,
  Star,
  Bang,
  BangEqual,
  Equal,
  EqualEqual,
  Greater,
  GreaterEqual,
  Less,
  LessEqual,
  Identifier,
  Str,
  Number,
  And,
  Class,
  Else,
  False,
  Fun,
  For,
  If,
  Nil,
  Or,
  Print,
  Return,
  Super,
  This,
  True,
  Var,
  While,
  Eof,
  Illegal,
}
